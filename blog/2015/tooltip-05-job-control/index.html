<!DOCTYPE html>
<html>
 <head></head>
 <body>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>
   Tooltip #5: Job Control in bash — Ryan Artecona
  </title>
  <meta name="viewport" content="width=device-width">
  <link href="../../../css/main.css" rel="stylesheet">
  <div class="page-wrap">
   <div class="header-wrap">
    <div class="header" role="page-header">
     <header class="site-title-wrap">
      <a href="../../../" rel="home" title="Ryan Artecona">
        <span class="logo-wrap">
          <span class="logo-background">
            <img src="../../../images/RA_logo.png" class="logo" alt="Ryan Artecona">
          </span>
        </span>
        <span class="site-title">
          Ryan Artecona
        </span>
      </a>
     </header>
     <div class="nav" role="navigation">
      <ul class="nav-items">
       <li class="current nav-item">
        <a href="../../../blog">Blog</a>
       </li>
       <li class="nav-item">
        <a href="../../../about">About</a>
       </li>
      </ul>
     </div>
    </div>
   </div>
   <div class="page-main">
    <div class="page-content">
     <div class="article">
      <div class="entry-header">
       <h1 id="tooltip--5--job-control-in-bash" class="entry-title">
        Tooltip #5: Job Control in bash
       </h1>
      </div>
      <div class="entry-meta">
       <span class="entry-meta-item entry-date">2015-08-28</span>
              <span class="entry-meta-item entry-tags">tooltip</span>
      </div>
      <div class="entry-content">
       <p></p>
       <p>
        This is one of those features that fills a role which is almost always better filled by some other more powerful tool, but can nonetheless help you out in a pinch, or is at least a good thing to know about.
       </p>
       <p>
        You know you can run commands in the background in your shell, right? That thing where a README or tutorial will tell you to run a command with a trailing <code>&amp;</code>, so you can run other commands in the same shell while that command’s doing its own thing? That little feature fits in with a small group of shell builtins which all work together and collectively do ‘job control’.
       </p>
       <h2 id="the-commands">
        <a class="heading-anchor" href="#the-commands">#</a>The commands
       </h2>
       <p>
        The job control commands are <code>fg</code>, <code>bg</code>, and <code>jobs</code>. The other supplementary features are that trailing <code>&amp;</code> and the <code>^Z</code> key.
       </p>
       <h3 id="trailing--">
        <a class="heading-anchor" href="#trailing--">#</a>Trailing <code>&amp;</code>
       </h3>
       <p>
        This one you probably know. If you follow a command with a <code>&amp;</code> at the very end, it will run in the background. No matter how long the program takes to exit, you will immediately see a prompt where you can go on typing commands in the exact same shell environment. If it prints anything, that output will have a little battle with your prompt until you intervene.
       </p>
       <h3 id="-z">
        <a class="heading-anchor" href="#-z">#</a><code>^Z</code>
       </h3>
       <p>
        If you start a command, and realize it’s not going to exit as quickly as you thought it would, you have a few options. You might reach for the humane instruments of quick process death, <code>^D</code> to feed an EOF to its stdin, or <code>^C</code> to send it a ‘INT’ interrupt signal. Another option is to hit <code>^Z</code>, which functions more like cryogenically freezing the process.
       </p>
       <h3 id="jobs">
        <a class="heading-anchor" href="#jobs">#</a><code>jobs</code>
       </h3>
       <p>
        The <code>jobs</code> command will show you all the things you have in the background for your current shell session, which includes everything you ran with a trailing <code>&amp;</code>, and everything you stopped with <code>^Z</code>. The output of this command will show you something like this.
       </p>
       <pre><code>[1]+  Stopped                 sleep 3
[2]-  Running                 sleep 3 &amp;
</code></pre>
       <p>
        Here, the job will be ‘Running’ if it’s active and in the background, and ‘Stopped’ if it’s been stopped with <code>^Z</code>.
       </p>
       <p>
        Also, you can dereference one of those job numbers using <code>%</code> with the <code>kill</code> command.
       </p>
       <code class="language-bash"><pre class="highlight">$ <span class="nb">kill</span> %1

<span class="o">[</span>1<span class="o">]</span>+  Stopped                 sleep <span class="m">3</span>
$ <span class="nb">jobs</span>
<span class="o">[</span>1<span class="o">]</span>+  Terminated: <span class="m">15</span>          sleep <span class="m">3</span>
</pre></code>
       <h3 id="fg">
        <a class="heading-anchor" href="#fg">#</a><code>fg</code>
       </h3>
       <p>
        You can bring one of those background jobs listed in <code>jobs</code> back into the foreground with <code>fg</code>. You can pass <code>fg</code> a job number if you’ve got multiple in the background, otherwise it will default to the last job you interacted with (marked by the <code>+</code> in the jobs output). This will automatically resume the job if it’s in the ‘Stopped’ state.
       </p>
       <h3 id="bg">
        <a class="heading-anchor" href="#bg">#</a><code>bg</code>
       </h3>
       <p>
        The <code>bg</code> command will take a job that’s in the ‘Stopped’ state and resume it, but keep it in the background.
       </p>
       <p>
        Since the <code>^Z</code> key will <em>stop</em> a job, taking a job running in the foreground to running in the background takes two steps: first, you hit <code>^Z</code>, then you do a <code>bg</code>.
       </p>
       <h2 id="the-caveats">
        <a class="heading-anchor" href="#the-caveats">#</a>The caveats
       </h2>
       <p>
        These job control features are built into the shell, and are associated with a specific shell session (as far as I know). Typically, if you think you’ll need multiple things running at once before actually kicking off a command, you should reconsider your options before reaching for these rather primitive shell features. I hear <code>tmux</code> is a pretty good option (but still haven’t learned much of it myself :/ ).
       </p>
       <p>
        Also, a program is free to do whatever it wants in response to a <code>SIGTSTP</code>, the signal sent to a process when you hit <code>^Z</code>. Sometimes a program will misbehave in strange ways. Sometimes it will so expected-but-unfortunate things like kill a download that you actually wanted to keep running in the background.
       </p>
       <p>
        <em>However</em>, one thing that background jobs are more consistently useful for is to keep an editor like <code>vim</code> open on a file in the background. To move from a foreground editor back to the shell you opened it in, hit <code>^Z</code>, and you can move back into your editor exactly where you left off with a <code>fg</code>.
       </p>
       <h2 id="related">
        <a class="heading-anchor" href="#related">#</a>Related
       </h2>
       <p>
        I found this article called <a href="http://www.linusakesson.net/programming/tty/">“The TTY Demystified”</a> to be <em>super</em> interesting and helpful to understand some of these strange job control mechanisms (and more). It goes through an abridged history of why all the layers of software that make up a terminal work and interact the way they do, and into detail on how the mechanisms actually work, and what about them is user-configurable. Highly recommended!
       </p>
      </div>
     </div>
    </div>
   </div>
  </div>
  <script type="text/javascript">
   var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28816340-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
  </script>
 </body>
</html>
