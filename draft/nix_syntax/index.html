<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>
      
        Nix Syntax Primer
      
    </title>
    <meta name="viewport" content="width=device-width">

    <link rel="stylesheet" href="../../css/main.css">
  </head>

  <body>

    <div class="page-wrap">
      <div class="header-wrap">
        <div class="header" role="page-header">
          <h1 class="site-title-wrap">
            <a rel="home" href="../../" title="Ryan Artecona">
              <span class="logo-wrap">
                <span class="logo-background">
                  <img class="logo" src="../../images/RA_logo.png" alt="Ryan Artecona" />
                </span>
              </span>
              <span class="site-title">
                Ryan Artecona
              </span>
            </a>
          </h1>
          <div class="nav" role="navigation">
            <ul class="nav-items">
              <li class="nav-item current">
                <a href="../../">Posts</a>
              </li>
              <li class="nav-item">
                <a href="../../about">About</a>
              </li>
            </ul>
          </div>
        </div>
      </div>

      <div class="page-main">
        <div class="page-content">
          <div class="article">
  <div class="entry-header">
    <h2 class="entry-title">
      Nix Syntax Primer
    </h2>
  </div>

  <div class="entry-meta">
    <span class="entry-meta-item entry-date">
      January  9, 2017
    </span>
    
      <div class="toc"><ul>
<li><a href="#_preliminaries">Preliminaries</a><ul>
<li><a href="#_other_similar_primers">Other similar primers</a></li>
<li><a href="#_running_the_examples">Running the examples</a></li>
</ul></li>
<li><a href="#_basics">Basics</a><ul>
<li><a href="#_what_to_expect">What to expect</a></li>
<li><a href="#_json_types">JSON types</a></li>
</ul></li>
<li><a href="#_expression_forms">Expression forms</a><ul>
<li><a href="#_strings">Strings</a></li>
<li><a href="#_integers">Integers</a><ul>
<li><a href="#_todo_ints">TODO: Ints</a></li>
</ul></li>
<li><a href="#_booleans">Booleans</a></li>
<li><a href="#_arrays">Arrays</a><ul>
<li><a href="#_todo_arrays">TODO: Arrays</a></li>
</ul></li>
<li><a href="#_attribute_sets">Attribute sets</a><ul>
<li><a href="#_inheriting">Inheriting</a></li>
<li><a href="#_nested_definitions">Nested definitions</a></li>
</ul></li>
<li><a href="#_bindings_and_scopes">Bindings and scopes</a><ul>
<li><a href="#_literal_let_literal_binding"><code>let</code> binding</a></li>
<li><a href="#_literal_with_literal_expression"><code>with</code> expression</a></li>
</ul></li>
<li><a href="#_functions">Functions</a><ul>
<li><a href="#_currying">Currying</a></li>
<li><a href="#_named_arguments">Named arguments</a></li>
</ul></li>
<li><a href="#_paths">Paths</a></li>
</ul></li>
<li><a href="#_appendix">Appendix</a><ul>
<li><a href="#_appendix_a_currying">Appendix A: Currying</a></li>
</ul></li>
</ul></div>
    
  </div>

  <div class="entry-content">
    <h1 id="_preliminaries">Preliminaries</h1>
<p>Nix is the name shared by both the <a href="https://nixos.org/nix/manual">Nix package manager</a> and its <a href="https://nixos.org/nix/manual#ch-expression-language">Nix expression language</a>. The expression language is used extensively in working with Nix-the-package-manager and everything built on top of it, including for configuring the <a href="https://nixos.org/nixos/manual">NixOS</a> Linux distribution. This is a primer on the Nix expression language.</p>
<p>My hope is that with this guide — reading it, skimming it, or just keeping it handy if you get stuck — you can get your bearings enough to read through existing Nix code and, if you’re so inclined, start writing some of your own without fear.</p>
<p>I assume no prior familiarity with Nix, so you can start here from scratch. Familiarity with functional programming or a lazily evaluated language might help, but neither are required.</p>
<h2 id="_other_similar_primers">Other similar primers</h2>
<ul>
<li><p><a href="https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55" class="uri">https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55</a></p></li>
<li><p><a href="https://learnxinyminutes.com/docs/nix/" class="uri">https://learnxinyminutes.com/docs/nix/</a></p></li>
<li><p><a href="https://nixcloud.io/tour" class="uri">https://nixcloud.io/tour</a></p></li>
</ul>
<h2 id="_running_the_examples">Running the examples</h2>
<p>The <code>#</code> character begins line comments, so I will use <code>#-&gt;</code> in examples to denote what an expression evaluates to. I will write standalone examples whenever possible so they can be easily copied and run from your REPL.</p>
<p>There are a few ways to interactively evaluate Nix expressions. I recommend following along with the examples using one of these.</p>
<ul>
<li><p><a href="https://nixcloud.io/tour" class="uri">https://nixcloud.io/tour</a></p>
<p>This is its own beginner’s tour of the Nix language, but it includes an editor that can evaluate expressions Nix right on the page. I recommend this if you haven’t installed Nix on your computer or if you don’t have a terminal handy.</p></li>
<li><p><code>nix-repl</code></p>
<p>If you have already installed Nix on your computer, you may already know that you can install <code>nix-repl</code> with <code>nix-env --install nix-repl</code>. It’s nothing fancy, but it’s better than no REPL. Use <code>:?</code> for help with commands. One unfortunate caveat is <code>nix-repl</code> doesn’t support multiline expressions, though sometimes it’s still worth it to explore unfamiliar territory with its tab completion.</p></li>
<li><p><code>nix-instantiate</code></p>
<p>If you already have Nix installed, you may also evaluate individual expressions with <code>nix-instantiate --eval --strict --expr '...'</code> or files with <code>nix-instantiate --eval --strict path/to/file.nix</code>. A Nix file just contains one big expression. If you want to paste examples verbatim into your terminal, something like <code>pbpaste | tee /dev/stderr | nix-instantiate --eval --strict -</code> should work fine (it’s how I’ve checked my examples).</p></li>
</ul>
<h1 id="_basics">Basics</h1>
<h2 id="_what_to_expect">What to expect</h2>
<p>Before getting to details, here’s some orientation.</p>
<ul>
<li><p>Nix expressions have <strong>no side effects</strong>.</p></li>
<li><p>Nix expressions are <strong>lazily evaluated</strong>.</p></li>
<li><p>Nix expressions are <strong>immutable</strong>.</p></li>
<li><p>Nix expressions are <strong>dynamically typed</strong>.</p></li>
<li><p>Nix expressions require <strong>no compilation</strong>.</p></li>
<li><p>Nix expressions are <strong>insensitive to whitespace</strong>.</p></li>
</ul>
<p>Nix is fundamentally a <em>configuration language</em>, not a general-purpose programming language. Its purpose is to …</p>
<h2 id="_json_types">JSON types</h2>
<p>Nix has most of the same primitive value types as JSON, namely: numbers, booleans, strings, and <code>null</code>. One notable exception is that Nix does not have floats, so all numbers are integers.</p>
<table>
<colgroup>
<col width="20%" />
<col width="40%" />
<col width="40%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Nix</th>
<th>JSON</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Number</p></td>
<td><p><code>1</code></p></td>
<td><p><code>1</code></p></td>
</tr>
<tr class="even">
<td><p>Float</p></td>
<td><p>n/a</p></td>
<td><p><code>3.14</code></p></td>
</tr>
<tr class="odd">
<td><p>Boolean</p></td>
<td><p><code>true</code></p></td>
<td><p><code>true</code></p></td>
</tr>
<tr class="even">
<td><p>Boolean</p></td>
<td><p><code>false</code></p></td>
<td><p><code>false</code></p></td>
</tr>
<tr class="odd">
<td><p>String</p></td>
<td><p><code>&quot;str&quot;</code></p></td>
<td><p><code>&quot;str&quot;</code></p></td>
</tr>
<tr class="even">
<td><p>Null</p></td>
<td><p><code>null</code></p></td>
<td><p><code>null</code></p></td>
</tr>
</tbody>
</table>
<p>Also like JSON, Nix has arrays and objects, albeit with slightly different syntax. Note that what JSON calls &quot;objects&quot;, Nix calls &quot;attribute sets&quot; or sometimes just &quot;sets&quot;.</p>
<table>
<colgroup>
<col width="20%" />
<col width="40%" />
<col width="40%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Nix</th>
<th>JSON</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Array</p></td>
<td><p><code>[1 2 3]</code></p></td>
<td><p><code>[1, 2, 3]</code></p></td>
</tr>
<tr class="even">
<td><p>Object/Set</p></td>
<td><p><code>{foo = &quot;bar&quot;; baz = &quot;quux&quot;;}</code></p></td>
<td><p><code>{&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;quux&quot;}</code></p></td>
</tr>
</tbody>
</table>
<p>Beyond these, Nix also has <em><strong>function</strong></em>, <em><strong>path</strong></em>, and <em><strong>derivation</strong></em> values and a few other sorts of expressions for writing actual programs.</p>
<p>We’ll cover all these below except for derivations, because derivations deserve their own primer.</p>
<h1 id="_expression_forms">Expression forms</h1>
<h2 id="_strings">Strings</h2>
<p>Concatenate with <code>+</code>.</p>
<div class="highlight"><pre><span class="s2">&quot;Hello &quot;</span> <span class="o">+</span> <span class="s2">&quot;world&quot;</span>
<span class="c1">#-&gt; &quot;Hello world&quot;</span>
</pre></div>

<p>Nix has string interpolation with <code>${...}</code>. You can put any expression in those braces.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">name =</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span>
<span class="k">in</span>
  <span class="s2">&quot;Hello </span><span class="si">${</span>name <span class="o">+</span> <span class="s2">&quot;!&quot;</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="c1">#-&gt; &quot;Hello world!&quot;</span>
</pre></div>

<p>You can also write strings inside double single-quotes, <code>''like this''</code>. This form allows multiline strings, and it will intelligently strip indentation!</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">name =</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span>
<span class="k">in</span>
  <span class="s1">''</span>
<span class="s1">  # This can be any text!</span>
<span class="s1">  echo &quot;Hello </span><span class="si">${</span>name<span class="si">}</span><span class="s1">&quot;</span>
<span class="s1">  </span><span class="se">''</span>
<span class="s1">#-&gt; &quot;# This can be any text!\necho \&quot;Hello world\&quot;\n&quot;</span>
</pre></div>

<div class="admonition note">
<p>Once you start using this, you’ll wish every language had multiline strings that were so pleasant. I know I do.</p>
</div>
<p>It’s common in the nixpkgs repo for bash code snippets and other config files to be written in strings this way.</p>
<h2 id="_integers">Integers</h2>
<h3 id="_todo_ints">TODO: Ints</h3>
<h2 id="_booleans">Booleans</h2>
<p>There’s not much to note about booleans. There’s conjunction with <code>&amp;&amp;</code>.</p>
<div class="highlight"><pre><span class="no">true</span> <span class="o">&amp;&amp;</span> <span class="no">false</span>
<span class="c1">#-&gt; false</span>
</pre></div>

<p>There’s disjunction with <code>||</code>.</p>
<div class="highlight"><pre><span class="no">true</span> <span class="o">||</span> <span class="no">false</span>
<span class="c1">#-&gt; true</span>
</pre></div>

<p>There’s negation with <code>!</code>.</p>
<div class="highlight"><pre><span class="o">!</span><span class="no">false</span>
<span class="c1">#-&gt; true</span>
</pre></div>

<p>The one boolean operator you may be less familiar with is <code>-&gt;</code> for implication.</p>
<div class="highlight"><pre><span class="no">true</span> <span class="o">-&gt;</span> <span class="no">true</span>
<span class="c1">#-&gt; true</span>
</pre></div>

<p>You can read <code>p -&gt; q</code> as &quot;<em>p</em> implies <em>q</em>&quot;. This means if <em>p</em> is true, then <em>q</em> must be true. It’s logically equivalent to <code>!(p &amp;&amp; !q)</code>, if that helps.</p>
<p>The <code>-&gt;</code> operator is usually only used to assert mutually consistent configuration options. If you write a package which allows setting two feature flags, <code>includeGUI</code> and <code>useFancyGUITheme</code>, and it only makes sense for <code>useFancyGUITheme</code> to be true if <code>includeGUI</code> is <em>also</em> true, then you might write <code>assert useFancyGUITheme -&gt; includeGUI;</code> to ensure your package won’t try to include a GUI theme without including the GUI.</p>
<h2 id="_arrays">Arrays</h2>
<h3 id="_todo_arrays">TODO: Arrays</h3>
<h2 id="_attribute_sets">Attribute sets</h2>
<p>An attribute set is like JSON’s &quot;Object&quot;, Ruby’s &quot;Hash&quot;, Python’s &quot;dict&quot;, etc., but with an obscure name. It’s a mapping from names to values.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">x =</span> <span class="p">{</span> <span class="ss">key =</span> <span class="s2">&quot;value&quot;</span><span class="p">;</span> <span class="p">};</span>
<span class="k">in</span>
  x<span class="o">.</span>key
<span class="c1">#-&gt; &quot;value&quot;</span>
</pre></div>

<p>An attribute name must be a string, but it can be any string. The value can be anything.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">x =</span> <span class="p">{</span><span class="s2">&quot;my key&quot;</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;};</span>
<span class="k">in</span>
  x<span class="o">.</span><span class="s2">&quot;my key&quot;</span>
<span class="c1">#-&gt; 3</span>
</pre></div>

<p>You can use string interpolation in attribute names, if you need to, both while defining and accessing.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">name =</span> <span class="s2">&quot;key&quot;</span><span class="p">;</span>
  <span class="ss">x =</span> <span class="p">{</span> <span class="s2">&quot;</span><span class="si">${</span>name<span class="si">}</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span><span class="p">;</span> <span class="p">};</span>
<span class="k">in</span>
  x<span class="o">.</span><span class="s2">&quot;</span><span class="si">${</span>name<span class="si">}</span><span class="s2">&quot;</span>
<span class="c1">#-&gt; &quot;value&quot;</span>
</pre></div>

<p>You can also merge the attributes of two sets into one with <code>//</code>. The right hand side wins if attribute names conflict, and the merge is shallow.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">foo =</span> <span class="p">{</span><span class="ss">x =</span> <span class="mi">1</span><span class="p">;</span> <span class="ss">z =</span> <span class="p">{</span><span class="ss">a =</span> <span class="s2">&quot;a&quot;</span><span class="p">;};};</span>
  <span class="ss">bar =</span> <span class="p">{</span><span class="ss">y =</span> <span class="mi">3</span><span class="p">;</span> <span class="ss">z =</span> <span class="p">{</span><span class="ss">b =</span> <span class="s2">&quot;b&quot;</span><span class="p">;};};</span>
<span class="k">in</span>
  <span class="p">(</span>foo <span class="o">//</span> bar<span class="p">)</span>
<span class="c1">#-&gt; { x = 1; y = 3; z = { b = &quot;b&quot;; }; }</span>
</pre></div>

<h3 id="_inheriting">Inheriting</h3>
<p>If you want to turn a bound name into an attribute in a set, you can use <code>inherit ...;</code>.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">x =</span> <span class="mi">1</span><span class="p">;</span>
  <span class="ss">y =</span> <span class="mi">2</span><span class="p">;</span>
  <span class="ss">z =</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">in</span>
  <span class="p">{</span>
    <span class="ss">x =</span> x<span class="p">;</span>
    <span class="k">inherit</span> y z<span class="p">;</span>
  <span class="p">}</span>
<span class="c1">#-&gt; { x = 1; y = 2; z = 3; }</span>
</pre></div>

<div class="admonition note">
<p>This is in a way the opposite of <a href="#_literal_with_literal_expression"><code>with</code> expressions</a>, which turn attributes of a set into bound names.</p>
</div>
<p>This feature is similar to &quot;field punning&quot; in some languages or &quot;property value shorthand&quot; in ES6, so it may feel familiar if you can see past the <code>inherit</code> keyword.</p>
<p>If want to cherry pick specific attributes in one set to include in another set, you may use an alternate form of <code>inherit</code>.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">foo =</span> <span class="p">{</span><span class="ss">x =</span> <span class="mi">1</span><span class="p">;</span> <span class="ss">y =</span> <span class="mi">2</span><span class="p">;};</span>
<span class="k">in</span>
  <span class="p">{</span> <span class="k">inherit</span> <span class="p">(</span>foo<span class="p">)</span> x y<span class="p">;</span> <span class="p">}</span>
<span class="c1">#-&gt; { x = 1; y = 2; }</span>
</pre></div>

<p>The parens around <code>(foo)</code> are necessary here, as they change the meaning of <code>inherit</code>! It’s unfortunate syntax, but important to know.</p>
<h3 id="_nested_definitions">Nested definitions</h3>
<p>Sometimes when writing Nix code you have to work with deeply nested attribute sets, such as when writing a configuration file for a NixOS machine.</p>
<p>Nix provides a shorthand for defining nested attribute sets which can make them easier to read and write.</p>
<div class="highlight"><pre><span class="p">{</span>
  <span class="ss">explicit =</span> <span class="p">{</span>
    <span class="ss">a =</span> <span class="mi">1</span><span class="p">;</span>
    <span class="ss">b =</span> <span class="p">{</span>
      <span class="ss">c =</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">};</span>
  short<span class="o">.</span><span class="ss">a =</span> <span class="mi">1</span><span class="p">;</span>
  short<span class="o">.</span>b<span class="o">.</span><span class="ss">c =</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#-&gt; { explicit = { a = 1; b = { c = 2; }; }; short = { a = 1; b = { c = 2; }; }; }</span>
</pre></div>

<p>Just know that you can’t mix and match these styles in an ambiguous way. Each key, at any level, can use one or the other style but not both.</p>
<div class="highlight"><pre><span class="p">{</span>
  foo<span class="o">.</span><span class="ss">a =</span> <span class="mi">1</span><span class="p">;</span>
  <span class="ss">foo =</span> <span class="p">{</span>
    <span class="ss">b =</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
<span class="c1">#-&gt; error: attribute ‘foo’ at (string):3:3 already defined at (string):2:3</span>
</pre></div>

<h2 id="_bindings_and_scopes">Bindings and scopes</h2>
<h3 id="_literal_let_literal_binding"><code>let</code> binding</h3>
<p>If you haven’t already guessed, you can bind a name to a value with <code>let ... = ...; in ...</code>.</p>
<div class="highlight"><pre><span class="k">let</span> <span class="ss">x =</span> <span class="s2">&quot;value&quot;</span><span class="p">;</span> <span class="k">in</span> <span class="p">{</span><span class="ss">key =</span> x<span class="p">;}</span>
<span class="c1">#-&gt; { key = &quot;value&quot;; }</span>
</pre></div>

<p>Note that these are constant bindings to immutable values. You can reuse a bound name in an inner scope (&quot;shadowing&quot; it), but you can’t reassign it or otherwise change a value once it’s assigned. These aren’t what most languages call &quot;variables&quot;.</p>
<p>You can bind multiple names in a single <code>let</code> expression.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">x =</span> <span class="mi">1</span><span class="p">;</span>
  <span class="ss">y =</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">in</span>
  x <span class="o">+</span> y
<span class="c1">#-&gt; 3</span>
</pre></div>

<p>You should also know that a <code>let</code> binding is just another type of expression, so you can use one inside another.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">first =</span> <span class="p">(</span>
    <span class="k">let</span>
      <span class="ss">second =</span> <span class="s2">&quot;Hello&quot;</span><span class="p">;</span>
    <span class="k">in</span>
      second <span class="o">+</span> <span class="s2">&quot; &quot;</span>
  <span class="p">);</span>
<span class="k">in</span>
  <span class="k">let</span>
    <span class="ss">third =</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span>
  <span class="k">in</span>
    first <span class="o">+</span> third
<span class="c1">#-&gt; &quot;Hello world&quot;</span>
</pre></div>

<h3 id="_literal_with_literal_expression"><code>with</code> expression</h3>
<p>A <code>with</code> expression brings all the attributes in a set into scope. It exists purely for convenience, as it’s often much more pleasant than using fully qualified names or lots of <code>let</code> bindings instead.</p>
<table>
<colgroup>
<col width="33%" />
<col width="66%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>qualified names</p></td>
<td><div class="highlight"><pre><span class="k">let</span>
  <span class="ss">pkgs =</span> <span class="nb">import</span> <span class="l">&lt;nixpkgs&gt;</span> <span class="p">{};</span>
<span class="k">in</span>
  <span class="p">[</span>pkgs<span class="o">.</span>foo pkgs<span class="o">.</span>bar pkgs<span class="o">.</span>baz<span class="p">]</span>
</pre></div>
</td>
</tr>
<tr class="even">
<td><p>local bindings</p></td>
<td><div class="highlight"><pre><span class="k">let</span>
  <span class="ss">pkgs =</span> <span class="nb">import</span> <span class="l">&lt;nixpkgs&gt;</span> <span class="p">{};</span>
  <span class="ss">foo =</span> pkgs<span class="o">.</span>foo<span class="p">;</span>
  <span class="ss">bar =</span> pkgs<span class="o">.</span>bar<span class="p">;</span>
  <span class="ss">baz =</span> pkgs<span class="o">.</span>baz<span class="p">;</span>
<span class="k">in</span>
  <span class="p">[</span>foo bar baz<span class="p">]</span>
</pre></div>
</td>
</tr>
<tr class="odd">
<td><p><code>with</code> expression</p></td>
<td><div class="highlight"><pre><span class="k">let</span>
  <span class="ss">pkgs =</span> <span class="nb">import</span> <span class="l">&lt;nixpkgs&gt;</span> <span class="p">{};</span>
<span class="k">in</span>
  <span class="k">with</span> pkgs<span class="p">;</span>
  <span class="p">[</span>foo bar baz<span class="p">]</span>
</pre></div>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p>All 3 above examples evaluate to the same thing.</p>
</div>
<p>The one big caveat with <code>with</code> expressions is that a name bound by <code>with</code> <em>cannot shadow</em> a name that was already bound. Another way to think about this is that <em>explicit</em> <code>let</code> bindings take precedence over <em>implicit</em> <code>with</code> bindings, <em>even if</em> the <code>with</code> comes after.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">item =</span> <span class="s2">&quot;we want this&quot;</span><span class="p">;</span>
  <span class="ss">suspiciousSet =</span> <span class="p">{</span><span class="ss">item =</span> <span class="s2">&quot;we don't want this&quot;</span><span class="p">;};</span>
<span class="k">in</span>
  <span class="k">with</span> suspiciousSet<span class="p">;</span> item
<span class="c1">#-&gt; &quot;we want this&quot;</span>
</pre></div>

<p>This lets you use <code>with</code> on a set for convenience without fear that it might clobber your local bindings and break your code.</p>
<h2 id="_functions">Functions</h2>
<p>Basic function syntax is quite terse: you have an argument on the left and a function body on the right separated only by a <code>:</code>. It’s sometimes easy to miss if you’re not looking for it.</p>
<p>Here is a function which simply adds <code>1</code> to its argument.</p>
<div class="highlight"><pre>x<span class="p">:</span> x <span class="o">+</span> <span class="mi">1</span>
<span class="c1">#-&gt; «lambda»</span>
</pre></div>

<p>Nix often calls a function a &quot;lambda&quot;. There’s no distinction. They aren’t strings in disguise like in <em>some</em> silly languages, so if you try to print one, Nix just says <code>«lambda»</code>.</p>
<p>To apply a function to an argument, simply place the argument after the function.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">add1 =</span> <span class="p">(</span>x<span class="p">:</span> x <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">in</span>
  add1 <span class="mi">2</span>
<span class="c1">#-&gt; 3</span>
</pre></div>

<h3 id="_currying">Currying</h3>
<p>All functions in Nix take exactly 1 argument (they’re &quot;unary&quot;). Technically speaking, you can’t define a function which takes more than 1 argument.</p>
<p>But this isn’t a limitation! We can get something that looks and behaves like a multi-argument function by writing it in a curried style: you write a function which takes the first argument, and it returns <em>another</em> function which takes the next argument, and when you have all your arguments in scope you can return the real result of the function.</p>
<div class="highlight"><pre><span class="p">(</span>x<span class="p">:</span> <span class="p">(</span>y<span class="p">:</span> x <span class="o">+</span> y<span class="p">))</span>
</pre></div>

<p>You can drop those parentheses without changing how the expression is grouped, which makes curried functions easier to read and write.</p>
<div class="highlight"><pre>x<span class="p">:</span> y<span class="p">:</span> x <span class="o">+</span> y
</pre></div>

<p>The <code>:</code> in a function definition is &quot;right associative&quot;, so <code>x: y: x + y</code> means the same thing as <code>(x: (y: (x + y)))</code>.</p>
<p>To use a curried function, simply supply all the arguments.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">add =</span> <span class="p">(</span>x<span class="p">:</span> y<span class="p">:</span> x <span class="o">+</span> y<span class="p">);</span>
<span class="k">in</span>
  add <span class="mi">1</span> <span class="mi">2</span>
<span class="c1">#-&gt; 3</span>
</pre></div>

<p>Function application is &quot;left associative&quot;, so <code>add 1 2</code> means the same thing as <code>(((add) 1) 2)</code>.</p>
<div class="admonition note">
<p>See <a href="#_appendix_a_currying">Appendix A: Currying</a> for more.</p>
</div>
<h3 id="_named_arguments">Named arguments</h3>
<p>Functions can also destructure attribute set arguments.</p>
<div class="highlight"><pre><span class="p">{</span>x<span class="p">,</span> y<span class="p">}:</span> x <span class="o">+</span> y
</pre></div>

<p>The above function expects a single set argument which has two elements: <code>x</code> and <code>y</code>. This is often used to pass named arguments to a function.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">add =</span> <span class="p">({</span>x<span class="p">,</span> y<span class="p">}:</span>
    x <span class="o">+</span> y
  <span class="p">);</span>
<span class="k">in</span>
  add <span class="p">{</span><span class="ss">x =</span> <span class="mi">1</span><span class="p">;</span> <span class="ss">y =</span> <span class="mi">2</span><span class="p">;}</span>
<span class="c1">#-&gt; 3</span>
</pre></div>

<p>Note that such a function requires an attribute set which has <em>exactly</em> the keys used in the pattern. Missing or unexpected keys will cause an error.</p>
<p>To allow extra keys to be ignored, you can mention <code>...</code>.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">hello =</span> <span class="p">({</span>name<span class="p">,</span> <span class="o">...</span><span class="p">}:</span>
    <span class="s2">&quot;Hello </span><span class="si">${</span>name<span class="si">}</span><span class="s2">&quot;</span>
  <span class="p">);</span>
<span class="k">in</span>
  hello <span class="p">{</span><span class="ss">name =</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span> <span class="ss">x =</span> <span class="no">false</span><span class="p">;}</span>
<span class="c1">#-&gt; &quot;Hello world&quot;</span>
</pre></div>

<p>To allow missing keys, you can give them default values with <code>?</code>.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">hello =</span> <span class="p">({</span>name <span class="o">?</span> <span class="s2">&quot;world&quot;</span><span class="p">}:</span>
    <span class="s2">&quot;Hello </span><span class="si">${</span>name<span class="si">}</span><span class="s2">&quot;</span>
  <span class="p">);</span>
<span class="k">in</span>
  hello <span class="p">{}</span>
<span class="c1">#-&gt; &quot;Hello world&quot;</span>
</pre></div>

<h2 id="_paths">Paths</h2>
<div class="highlight"><pre><span class="k">let</span> <span class="ss">path =</span> <span class="o">.</span><span class="l">/config.yml</span><span class="p">;</span> <span class="k">in</span> <span class="s2">&quot;</span><span class="si">${</span>path<span class="si">}</span><span class="s2">&quot;</span>
</pre></div>

<div class="highlight"><pre>nix-instantiate -I <span class="nv">mypath</span><span class="o">=</span>./ --eval <span class="s2">&quot;&lt;mypath&gt;&quot;</span>
</pre></div>

<h1 id="_appendix">Appendix</h1>
<h2 id="_appendix_a_currying">Appendix A: Currying</h2>
<p>If you’re unfamiliar with currying, here’s how a curried <code>add</code> function could be written and used in Javascript.</p>
<div class="highlight"><pre><span class="kr">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="k">return</span> <span class="p">((</span><span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">})};</span>
<span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">//-&gt; (y) =&gt; {return x + y}</span>
<span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">//-&gt; 3</span>
<span class="kr">const</span> <span class="nx">add1</span> <span class="o">=</span> <span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">add1</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">//-&gt; 3</span>
</pre></div>

<p>If you’d like to read up more on currying, introductory blog posts abound. You can google for one in your language of choice. If you understand what’s going on above, though, that’s really all there is to it.</p>
  </div>
</div>

        </div>
      </div>

    </div>

  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28816340-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
  </body>
</html>
