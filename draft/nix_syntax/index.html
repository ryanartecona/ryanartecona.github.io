<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>
      
        Nix Syntax Primer
      
    </title>
    <meta name="viewport" content="width=device-width">

    <link rel="stylesheet" href="../../css/main.css">
  </head>

  <body>

    <div class="page-wrap">
      <div class="header-wrap">
        <div class="header" role="page-header">
          <h1 class="site-title-wrap">
            <a rel="home" href="../../" title="Ryan Artecona">
              <span class="logo-wrap">
                <span class="logo-background">
                  <img class="logo" src="../../images/RA_logo.png" alt="Ryan Artecona" />
                </span>
              </span>
              <span class="site-title">
                Ryan Artecona
              </span>
            </a>
          </h1>
          <div class="nav" role="navigation">
            <ul class="nav-items">
              <li class="nav-item current">
                <a href="../../">Posts</a>
              </li>
              <li class="nav-item">
                <a href="../../about">About</a>
              </li>
            </ul>
          </div>
        </div>
      </div>

      <div class="page-main">
        <div class="page-content">
          <div class="article">
  <div class="entry-header">
    <h2 class="entry-title">
      Nix Syntax Primer
    </h2>
  </div>

  <div class="entry-meta">
    <span class="entry-meta-item entry-date">
      January  9, 2017
    </span>
  </div>

  <div class="entry-content">
    
      <div class="toc"><ul>
<li><a href="#_intro">Intro</a><ul>
<li><a href="#_other_similar_primers">Other similar primers</a></li>
</ul></li>
<li><a href="#_basics">Basics</a><ul>
<li><a href="#_what_to_expect">What to expect</a></li>
<li><a href="#_json_types">JSON types</a></li>
<li><a href="#_running_the_examples">Running the examples</a></li>
</ul></li>
<li><a href="#_expression_forms">Expression forms</a><ul>
<li><a href="#_strings">Strings</a></li>
<li><a href="#_integers">Integers</a></li>
<li><a href="#_booleans">Booleans</a><ul>
<li><a href="#_conditionals">Conditionals</a></li>
<li><a href="#_equality">Equality</a></li>
</ul></li>
<li><a href="#_lists">Lists</a></li>
<li><a href="#_attribute_sets">Attribute sets</a><ul>
<li><a href="#_attribute_membership">Attribute membership</a></li>
<li><a href="#_recursive_sets">Recursive sets</a></li>
<li><a href="#_inheriting">Inheriting</a></li>
<li><a href="#_nested_definitions">Nested definitions</a></li>
</ul></li>
<li><a href="#_bindings_and_scopes">Bindings and scopes</a><ul>
<li><a href="#_literal_let_literal_binding"><code>let</code> binding</a></li>
<li><a href="#_literal_with_literal_expression"><code>with</code> expression</a></li>
</ul></li>
<li><a href="#_functions">Functions</a><ul>
<li><a href="#_currying">Currying</a></li>
<li><a href="#_named_arguments">Named arguments</a></li>
</ul></li>
<li><a href="#_paths">Paths</a><ul>
<li><a href="#_todo_antiquoted_paths_in_derivations">TODO: antiquoted paths in derivations (?)</a></li>
<li><a href="#_todo_literal_nix_path_literal_amp_literal_lt_path_gt_literal">TODO: <code>NIX_PATH</code> &amp; <code>&lt;path&gt;</code></a></li>
</ul></li>
<li><a href="#_imports">Imports</a><ul>
<li><a href="#_todo_imports">TODO: Imports</a></li>
</ul></li>
</ul></li>
<li><a href="#_evaluation">Evaluation</a><ul>
<li><a href="#_todo_traces">TODO: Traces</a></li>
<li><a href="#_todo_errors_exceptions_assertions_aborts">TODO: Errors (exceptions, assertions, aborts)</a></li>
</ul></li>
<li><a href="#_standard_library">Standard library</a><ul>
<li><a href="#_builtins">builtins</a><ul>
<li><a href="#_todo_builtins">TODO: builtins</a></li>
</ul></li>
<li><a href="#_literal_nixpkgs_lib_literal"><code>nixpkgs/lib</code></a><ul>
<li><a href="#_todo_nixpkgs_lib">TODO: nixpkgs/lib</a></li>
</ul></li>
</ul></li>
<li><a href="#_appendix">Appendix</a><ul>
<li><a href="#_appendix_a_currying">Appendix A: Currying</a></li>
</ul></li>
</ul></div>
    
    <h1 id="_intro">Intro</h1>
<p>Nix is the name shared by both the <a href="https://nixos.org/nix/manual">Nix package manager</a> and its <a href="https://nixos.org/nix/manual#ch-expression-language">Nix expression language</a>. The expression language is used extensively in working with Nix-the-package-manager and everything built on top of it, including for configuring the <a href="https://nixos.org/nixos/manual">NixOS</a> Linux distribution. This is a primer on the Nix expression language.</p>
<p>My hope is that with this guide — reading it, skimming it, or just keeping it handy if you get stuck — you can get your bearings enough to read through existing Nix code and, if you’re so inclined, start writing some of your own without fear.</p>
<p>I assume no prior familiarity with Nix, so you can start here from scratch. Familiarity with functional programming or a lazily evaluated language might help, but neither are required.</p>
<h2 id="_other_similar_primers">Other similar primers</h2>
<ul>
<li><p><a href="https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55" class="uri">https://medium.com/@MrJamesFisher/nix-by-example-a0063a1a4c55</a></p></li>
<li><p><a href="https://learnxinyminutes.com/docs/nix/" class="uri">https://learnxinyminutes.com/docs/nix/</a></p></li>
<li><p><a href="https://nixcloud.io/tour" class="uri">https://nixcloud.io/tour</a></p></li>
</ul>
<h1 id="_basics">Basics</h1>
<h2 id="_what_to_expect">What to expect</h2>
<p>Before getting to details, here’s some orientation.</p>
<ul>
<li><p>Nix expressions are <strong>immutable</strong>.</p></li>
<li><p>Nix expressions have <strong>no side effects</strong>.</p></li>
<li><p>Nix expressions are <strong>lazily evaluated</strong>.</p></li>
<li><p>Nix expressions are <strong>dynamically typed</strong>.</p></li>
<li><p>Nix expressions require <strong>no compilation</strong>.</p></li>
<li><p>Nix expressions are <strong>insensitive to whitespace</strong>.</p></li>
</ul>
<p>Nix is fundamentally a <em>configuration language</em>, not a general-purpose programming language. You can’t use it (alone) to write a web server, or a kernel extension, or a Chrome extension, or an Android app. I have come to think of Nix as more like a &quot;programmable JSON&quot; than anything, where by &quot;programmable&quot; I mean proper <em>lambda calculus</em>, not some half-measure like <a href="http://docs.ansible.com/ansible/">YAML with embedded string templates</a> or <a href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/">a part-JSON, part-SQL exquisite corpse</a>.</p>
<p>The purpose of the Nix language is to <em>deterministically create files and directories and manage their interdependencies</em>. If you have a Nix expression for a software package, you want it to build the same exact package every time, in all contexts, even if you have other versions of the same package already installed, even if you build it on a totally different computer, and even if you walk away from it and come back to it in a year.</p>
<p>To that end, the Nix language itself is geared to be deterministic. Immutability and the lack of side effects help make it very difficult to write non-deterministic expressions. There <em>are</em> a few pieces of context a nix expression can choose to be sensitive to — environment variables, contents of other local files, platform of current computer — but those are only used when necessary. On top of the immutable, side effect-free foundation, lazy evaluation lends flexibility and efficiency, especially with large expressions like the nixpkgs package set.</p>
<h2 id="_json_types">JSON types</h2>
<p>Nix has most of the same primitive value types as JSON, namely: numbers, booleans, strings, and <code>null</code>. One notable exception is that Nix does not have floats, so all numbers are integers.</p>
<table>
<colgroup>
<col width="20%" />
<col width="40%" />
<col width="40%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Nix</th>
<th>JSON</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Number</p></td>
<td><p><code>1</code></p></td>
<td><p><code>1</code></p></td>
</tr>
<tr class="even">
<td><p>Float</p></td>
<td><p><em>n/a</em></p></td>
<td><p><code>3.14</code></p></td>
</tr>
<tr class="odd">
<td><p>Boolean</p></td>
<td><p><code>true</code></p></td>
<td><p><code>true</code></p></td>
</tr>
<tr class="even">
<td><p>String</p></td>
<td><p><code>&quot;str&quot;</code></p></td>
<td><p><code>&quot;str&quot;</code></p></td>
</tr>
<tr class="odd">
<td><p>Null</p></td>
<td><p><code>null</code></p></td>
<td><p><code>null</code></p></td>
</tr>
</tbody>
</table>
<p>Also like JSON, Nix has lists and objects, albeit with slightly different syntax. Note that what JSON calls &quot;objects&quot;, Nix calls &quot;attribute sets&quot; or sometimes just &quot;sets&quot;.</p>
<table>
<colgroup>
<col width="20%" />
<col width="40%" />
<col width="40%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>Nix</th>
<th>JSON</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>List</p></td>
<td><p><code>[1 2 3]</code></p></td>
<td><p><code>[1, 2, 3]</code></p></td>
</tr>
<tr class="even">
<td><p>Object/Set</p></td>
<td><p><code>{foo = &quot;bar&quot;; baz = &quot;quux&quot;;}</code></p></td>
<td><p><code>{&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: &quot;quux&quot;}</code></p></td>
</tr>
</tbody>
</table>
<p>Beyond these, Nix also has <em><strong>function</strong></em>, <em><strong>path</strong></em>, and <em><strong>derivation</strong></em> values and a few other sorts of expressions for writing actual programs.</p>
<p>We’ll cover all these below except for derivations, because derivations deserve their own primer.</p>
<h2 id="_running_the_examples">Running the examples</h2>
<p>The <code>#</code> character begins line comments, so I will use <code>#-&gt;</code> in examples to denote what an expression evaluates to. I will write standalone examples whenever possible so they can be easily copied and run from your REPL.</p>
<p>There are a few ways to interactively evaluate Nix expressions. I recommend following along with the examples using one of these.</p>
<ul>
<li><p><a href="https://nixcloud.io/tour" class="uri">https://nixcloud.io/tour</a></p>
<p>This is its own beginner’s tour of the Nix language, but it includes an editor that can evaluate expressions Nix right on the page. I recommend this if you haven’t installed Nix on your computer or if you don’t have a terminal handy.</p></li>
<li><p><code>nix-repl</code></p>
<p>If you have already installed Nix on your computer, you may already know that you can install <code>nix-repl</code> with <code>nix-env --install nix-repl</code>. It’s nothing fancy, but it’s better than no REPL. Use <code>:?</code> for help with commands. One unfortunate caveat is <code>nix-repl</code> doesn’t support multiline expressions, though sometimes it’s still worth it to explore unfamiliar territory with its tab completion.</p></li>
<li><p><code>nix-instantiate</code></p>
<p>If you already have Nix installed, you may also evaluate individual expressions with <code>nix-instantiate --eval --strict --expr '...'</code> or files with <code>nix-instantiate --eval --strict path/to/file.nix</code>. A Nix file just contains one big expression. If you want to paste examples verbatim into your terminal, something like <code>pbpaste | tee /dev/stderr | nix-instantiate --eval --strict -</code> should work fine (it’s how I’ve checked my examples).</p></li>
</ul>
<h1 id="_expression_forms">Expression forms</h1>
<h2 id="_strings">Strings</h2>
<p>Concatenate with <code>+</code>.</p>
<div class="highlight"><pre><span class="s2">&quot;Hello &quot;</span> <span class="o">+</span> <span class="s2">&quot;world&quot;</span>
<span class="c1">#-&gt; &quot;Hello world&quot;</span>
</pre></div>

<p>Nix has string interpolation with <code>${...}</code>, though in Nix land it usually goes by the less familiar name of &quot;antiquotation&quot;. You can put any expression in those braces.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">name =</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span>
<span class="k">in</span>
  <span class="s2">&quot;Hello </span><span class="si">${</span>name <span class="o">+</span> <span class="s2">&quot;!&quot;</span><span class="si">}</span><span class="s2">&quot;</span>
<span class="c1">#-&gt; &quot;Hello world!&quot;</span>
</pre></div>

<p>You can also write strings inside double single-quotes, <code>''like this''</code>. This form allows multiline strings, and it will intelligently strip indentation!</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">name =</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span>
<span class="k">in</span>
  <span class="s1">''</span>
<span class="s1">  # This can be any text!</span>
<span class="s1">  echo &quot;Hello </span><span class="si">${</span>name<span class="si">}</span><span class="s1">&quot;</span>
<span class="s1">  </span><span class="se">''</span>
<span class="s1">#-&gt; &quot;# This can be any text!\necho \&quot;Hello world\&quot;\n&quot;</span>
</pre></div>

<div class="admonition note">
<p>Once you start using this, you’ll wish every language had multiline strings that were so pleasant. I know I do.</p>
</div>
<p>It’s common in the nixpkgs repo for bash code snippets and other config files to be written in strings this way.</p>
<h2 id="_integers">Integers</h2>
<p>Integers in Nix are as you might expect.</p>
<div class="highlight"><pre><span class="mi">2</span> <span class="err">*</span> <span class="mi">4</span> <span class="err">-</span> <span class="mi">8</span> <span class="err">/</span> <span class="p">(</span><span class="mi">5</span> <span class="err">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">#-&gt; 6</span>
</pre></div>

<p>Integers are 64 or 32 bits, depending on your system.</p>
<div class="highlight"><pre><span class="mi">9223372036854775807</span> <span class="o">+</span> <span class="mi">1</span>
<span class="c1">#-&gt; -9223372036854775808</span>
</pre></div>

<p>Because Nix has no floating point numbers, all division is integer division.</p>
<div class="highlight"><pre><span class="mi">5</span> <span class="err">/</span> <span class="mi">3</span>
<span class="c1">#-&gt; 1</span>
</pre></div>

<p>Just don’t write a division without spaces.</p>
<div class="highlight"><pre><span class="mi">2</span><span class="l">/1</span>
<span class="c1">#-&gt; /Users/ryanartecona/blog/2/1</span>
</pre></div>

<p>What? This happens because <code>/</code> without surrounding spaces gets interpreted as a path separator, so <code>2/1</code> gets interpreted as a relative path instead of arithmetic, and that path gets expanded to an absolute path automatically. More about <a href="#_paths">Paths</a> below.</p>
<h2 id="_booleans">Booleans</h2>
<p>The main boolean operators are probably familiar to you.</p>
<table>
<colgroup>
<col width="33%" />
<col width="66%" />
</colgroup>
<thead>
<tr class="header">
<th>Operation</th>
<th>Expression</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>Conjunction</p></td>
<td><div class="highlight"><pre><span class="no">true</span> <span class="o">&amp;&amp;</span> <span class="no">false</span>
<span class="c1">#-&gt; false</span>
</pre></div>
</td>
</tr>
<tr class="even">
<td><p>Disjunction</p></td>
<td><div class="highlight"><pre><span class="no">true</span> <span class="o">||</span> <span class="no">false</span>
<span class="c1">#-&gt; true</span>
</pre></div>
</td>
</tr>
<tr class="odd">
<td><p>Negation</p></td>
<td><div class="highlight"><pre><span class="o">!</span><span class="no">false</span>
<span class="c1">#-&gt; true</span>
</pre></div>
</td>
</tr>
<tr class="even">
<td><p>Implication</p></td>
<td><div class="highlight"><pre><span class="no">true</span> <span class="o">-&gt;</span> <span class="no">false</span>
<span class="c1">#-&gt; false</span>
</pre></div>
</td>
</tr>
</tbody>
</table>
<p>The one boolean operator you may be less familiar with is <code>-&gt;</code> for implication.</p>
<p>You can read <code>p -&gt; q</code> as &quot;<em>p</em> implies <em>q</em>&quot;. This means if <em>p</em> is true, then <em>q</em> must be true. It’s logically equivalent to <code>!p || q</code>, if that helps.</p>
<p>The <code>-&gt;</code> operator is usually only used to assert mutually consistent configuration options. Imagine you write a package which allows setting two feature flags, <code>includeGUI</code> and <code>useFancyGUITheme</code>. If it only makes sense for <code>useFancyGUITheme</code> to be true if <code>includeGUI</code> is <em>also</em> true, then you might write <code>assert useFancyGUITheme -&gt; includeGUI;</code> to ensure your package won’t try to include a GUI theme without including the GUI.</p>
<p>All boolean operators in Nix expect proper boolean values. They won’t coerce non-boolean values to booleans, so there’s no notion of &quot;truthy&quot; or &quot;falsy&quot; values like in some languages.</p>
<div class="highlight"><pre><span class="no">true</span> <span class="o">&amp;&amp;</span> <span class="no">null</span>
<span class="c1">#-&gt; error: value is null while a Boolean was expected, at (string):1:1</span>
</pre></div>

<h3 id="_conditionals">Conditionals</h3>
<p>You can write a conditional expression with <code>if ... then ... else ...</code>.</p>
<div class="highlight"><pre><span class="k">if</span> <span class="no">true</span>
  <span class="k">then</span> <span class="s2">&quot;it was true&quot;</span>
  <span class="k">else</span> <span class="s2">&quot;it was false&quot;</span>
<span class="c1">#-&gt; &quot;it was true&quot;</span>
</pre></div>

<p>Just remember that this is an <code>if</code> <em>expression</em>, not an <code>if</code> <em>statement</em>. It evaluates to either the expression in the <code>then</code> branch or the expression in the <code>else</code> branch, but it’s not &quot;executed&quot;. Since there’s also no mutability or side effects in the Nix language, there would be little point to an <code>if ... then ...</code> without an <code>else</code> branch, so you must always give both the <code>then</code> branch and the <code>else</code> branch.</p>
<p>There’s no special syntax for chaining conditionals (no <code>elif</code> or <code>elsif</code>), but because they’re just ordinary expressions, you can nest them however you like. You might also like to keep indentation to a minimum with a little clever formatting.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">x =</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">in</span>
  <span class="k">if</span> x <span class="err">&lt;</span> <span class="mi">0</span> <span class="k">then</span>
    <span class="s2">&quot;negative&quot;</span>
  <span class="k">else</span> <span class="k">if</span> x <span class="err">&gt;</span> <span class="mi">0</span> <span class="k">then</span>
    <span class="s2">&quot;positive&quot;</span>
  <span class="k">else</span>
    <span class="s2">&quot;zero&quot;</span>
<span class="c1">#-&gt; &quot;positive&quot;</span>
</pre></div>

<h3 id="_equality">Equality</h3>
<p>Test for equality with <code>==</code>.</p>
<div class="highlight"><pre><span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>
<span class="c1">#-&gt; true</span>
</pre></div>

<p>You can test for equality with values of different type, and the test will just evaluate to <code>false</code>.</p>
<div class="highlight"><pre><span class="no">true</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span>
<span class="c1">#-&gt; false</span>
</pre></div>

<p>Two expressions are equal if they evaluate to the same value. Lists and attribute sets are equal if and only if all their elements are equal.</p>
<div class="highlight"><pre><span class="p">{</span>
  <span class="ss">listEq =</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">];</span>
  <span class="ss">setEq =</span> <span class="p">{</span> <span class="ss">x =</span> <span class="s2">&quot;x&quot;</span><span class="p">;</span> <span class="p">}</span> <span class="o">==</span> <span class="p">{</span> <span class="ss">x =</span> <span class="s2">&quot;x&quot;</span><span class="p">;</span> <span class="p">};</span>
<span class="p">}</span>
<span class="c1">#-&gt; { listEq = true; setEq = true; }</span>
</pre></div>

<p>One big thing to keep in mind is that functions always test as unequal to all other functions, even themselves.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">f =</span> <span class="p">(</span>x<span class="p">:</span> x<span class="p">);</span>
<span class="k">in</span>
  <span class="ss">f =</span><span class="o">=</span> f
<span class="c1">#-&gt; false</span>
</pre></div>

<p>This also means testing two lists or attribute sets for equality, if <em>either one</em> of them contains any functions, will <em>always</em> return <code>false</code>, even if they are otherwise equal.</p>
<div class="highlight"><pre><span class="p">{</span><span class="ss">a =</span> <span class="mi">1</span><span class="p">;</span> <span class="ss">f =</span> <span class="p">(</span>x<span class="p">:</span> x<span class="p">);}</span> <span class="o">==</span> <span class="p">{</span><span class="ss">a =</span> <span class="mi">1</span><span class="p">;</span> <span class="ss">f =</span> <span class="p">(</span>x<span class="p">:</span> x<span class="p">);}</span>
<span class="c1">#-&gt; false</span>
</pre></div>

<h2 id="_lists">Lists</h2>
<p>Lists in Nix are written in square brackets with just whitespace separating elements.</p>
<div class="highlight"><pre><span class="p">[</span> <span class="mi">1</span> <span class="no">true</span> <span class="no">null</span> <span class="p">]</span>
<span class="c1">#-&gt; [ 1 true null ]</span>
</pre></div>

<p>Concatenate lists with <code>++</code>.</p>
<div class="highlight"><pre><span class="p">[</span> <span class="mi">1</span> <span class="mi">2</span> <span class="p">]</span> <span class="o">++</span> <span class="p">[</span> <span class="mi">3</span> <span class="mi">4</span> <span class="p">]</span>
<span class="c1">#-&gt; [ 1 2 3 4 ]</span>
</pre></div>

<p>There’s no special syntax for indexing into a list. If you need to, you can use <code>builtins.elemAt</code>.</p>
<div class="highlight"><pre><span class="nb">builtins</span><span class="o">.</span>elemAt <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">1</span>
<span class="c1">#-&gt; 2</span>
</pre></div>

<div class="admonition note">
<p>The <code>builtins</code> here is, well, an attribute set full of inbuilt functions. See <a href="#_builtins">builtins</a>.</p>
</div>
<h2 id="_attribute_sets">Attribute sets</h2>
<p>An attribute set is like JSON’s &quot;Object&quot;, Ruby’s &quot;Hash&quot;, Python’s &quot;dict&quot;, etc., but with an obscure name. It’s a mapping from names to values.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">x =</span> <span class="p">{</span> <span class="ss">key =</span> <span class="s2">&quot;value&quot;</span><span class="p">;</span> <span class="p">};</span>
<span class="k">in</span>
  x<span class="o">.</span>key
<span class="c1">#-&gt; &quot;value&quot;</span>
</pre></div>

<p>An attribute name must be a string, but it can be any string. The value can be anything.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">x =</span> <span class="p">{</span> <span class="s2">&quot;my key&quot;</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span> <span class="p">};</span>
<span class="k">in</span>
  x<span class="o">.</span><span class="s2">&quot;my key&quot;</span>
<span class="c1">#-&gt; 3</span>
</pre></div>

<p>You can use string interpolation in attribute names, if you need to, both while defining and accessing.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">name =</span> <span class="s2">&quot;key&quot;</span><span class="p">;</span>
  <span class="ss">x =</span> <span class="p">{</span> <span class="s2">&quot;</span><span class="si">${</span>name<span class="si">}</span><span class="s2">&quot;</span> <span class="o">=</span> <span class="s2">&quot;value&quot;</span><span class="p">;</span> <span class="p">};</span>
<span class="k">in</span>
  x<span class="o">.</span><span class="s2">&quot;</span><span class="si">${</span>name<span class="si">}</span><span class="s2">&quot;</span>
<span class="c1">#-&gt; &quot;value&quot;</span>
</pre></div>

<p>You can also merge the attributes of two sets into one with <code>//</code>. The right hand side wins if attribute names conflict, and the merge is shallow.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">foo =</span> <span class="p">{</span> <span class="ss">x =</span> <span class="mi">1</span><span class="p">;</span> <span class="ss">z =</span> <span class="p">{</span> <span class="ss">a =</span> <span class="s2">&quot;a&quot;</span><span class="p">;</span> <span class="p">};</span> <span class="p">};</span>
  <span class="ss">bar =</span> <span class="p">{</span> <span class="ss">y =</span> <span class="mi">3</span><span class="p">;</span> <span class="ss">z =</span> <span class="p">{</span> <span class="ss">b =</span> <span class="s2">&quot;b&quot;</span><span class="p">;</span> <span class="p">};</span> <span class="p">};</span>
<span class="k">in</span>
  <span class="p">(</span>foo <span class="o">//</span> bar<span class="p">)</span>
<span class="c1">#-&gt; { x = 1; y = 3; z = { b = &quot;b&quot;; }; }</span>
</pre></div>

<h3 id="_attribute_membership">Attribute membership</h3>
<p>If you try to access a nonexistent attribute on a set, you get an error.</p>
<div class="highlight"><pre><span class="p">{</span> <span class="ss">x =</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span><span class="o">.</span>y
<span class="c1">#-&gt; error: attribute ‘y’ missing, at (string):1:1</span>
</pre></div>

<p>You can use <code>?</code> to check if a set has a certain key before trying to access it.</p>
<div class="highlight"><pre><span class="p">{</span> <span class="ss">x =</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span> <span class="o">?</span> y
<span class="c1">#-&gt; false</span>
</pre></div>

<h3 id="_recursive_sets">Recursive sets</h3>
<p>Usually, when you define a set, the attributes cannot refer to each other.</p>
<div class="highlight"><pre><span class="p">{</span>
  <span class="ss">name =</span> <span class="s2">&quot;hello-</span><span class="si">${</span>version<span class="si">}</span><span class="s2">&quot;</span><span class="p">;</span>
  <span class="ss">version =</span> <span class="s2">&quot;1.0&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#-&gt; error: undefined variable ‘version’ at (string):2:19</span>
</pre></div>

<p>You can always get around this by using a <code>let</code> binding, but often it’s more convenient to define a &quot;recursive&quot; set instead, which lets attributes refer to each other. You do this with the <code>rec</code> keyword.</p>
<div class="highlight"><pre><span class="k">rec</span> <span class="p">{</span>
  <span class="ss">name =</span> <span class="s2">&quot;hello-</span><span class="si">${</span>version<span class="si">}</span><span class="s2">&quot;</span><span class="p">;</span>
  <span class="ss">version =</span> <span class="s2">&quot;1.0&quot;</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#-&gt; { name = &quot;hello-1.0&quot;; version = &quot;1.0&quot;; }</span>
</pre></div>

<h3 id="_inheriting">Inheriting</h3>
<p>If you want to turn a bound name into an attribute in a set, you can use <code>inherit ...;</code>.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">x =</span> <span class="mi">1</span><span class="p">;</span>
  <span class="ss">y =</span> <span class="mi">2</span><span class="p">;</span>
  <span class="ss">z =</span> <span class="mi">3</span><span class="p">;</span>
<span class="k">in</span>
  <span class="p">{</span>
    <span class="ss">x =</span> x<span class="p">;</span>
    <span class="k">inherit</span> y z<span class="p">;</span>
  <span class="p">}</span>
<span class="c1">#-&gt; { x = 1; y = 2; z = 3; }</span>
</pre></div>

<div class="admonition note">
<p>This is in a way the opposite of <a href="#_literal_with_literal_expression"><code>with</code> expressions</a>, which turn attributes of a set into bound names.</p>
</div>
<p>This feature is similar to &quot;field punning&quot; in some languages or &quot;property value shorthand&quot; in ES6, so it may feel familiar if you can see past the <code>inherit</code> keyword.</p>
<p>If want to cherry pick specific attributes in one set to include in another set, you may use an alternate form of <code>inherit</code>.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">foo =</span> <span class="p">{</span><span class="ss">x =</span> <span class="mi">1</span><span class="p">;</span> <span class="ss">y =</span> <span class="mi">2</span><span class="p">;};</span>
<span class="k">in</span>
  <span class="p">{</span> <span class="k">inherit</span> <span class="p">(</span>foo<span class="p">)</span> x y<span class="p">;</span> <span class="p">}</span>
<span class="c1">#-&gt; { x = 1; y = 2; }</span>
</pre></div>

<p>The parens around <code>(foo)</code> are necessary here, as they change the meaning of <code>inherit</code>! It’s unfortunate syntax, but important to know.</p>
<h3 id="_nested_definitions">Nested definitions</h3>
<p>Sometimes when writing Nix code you have to work with deeply nested attribute sets, such as when writing a configuration file for a NixOS machine.</p>
<p>Nix provides a shorthand for defining nested attribute sets which can make them easier to read and write.</p>
<div class="highlight"><pre><span class="p">{</span>
  <span class="ss">explicit =</span> <span class="p">{</span>
    <span class="ss">a =</span> <span class="mi">1</span><span class="p">;</span>
    <span class="ss">b =</span> <span class="p">{</span>
      <span class="ss">c =</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">};</span>
  <span class="p">};</span>
  short<span class="o">.</span><span class="ss">a =</span> <span class="mi">1</span><span class="p">;</span>
  short<span class="o">.</span>b<span class="o">.</span><span class="ss">c =</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">#-&gt; { explicit = { a = 1; b = { c = 2; }; }; short = { a = 1; b = { c = 2; }; }; }</span>
</pre></div>

<p>Just know that you can’t mix and match these styles in an ambiguous way. Each key, at any level, can use one or the other style but not both.</p>
<div class="highlight"><pre><span class="p">{</span>
  foo<span class="o">.</span><span class="ss">a =</span> <span class="mi">1</span><span class="p">;</span>
  <span class="ss">foo =</span> <span class="p">{</span>
    <span class="ss">b =</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>
<span class="c1">#-&gt; error: attribute ‘foo’ at (string):3:3 already defined at (string):2:3</span>
</pre></div>

<h2 id="_bindings_and_scopes">Bindings and scopes</h2>
<h3 id="_literal_let_literal_binding"><code>let</code> binding</h3>
<p>If you haven’t already guessed, you can bind a name to a value with <code>let ... = ...; in ...</code>.</p>
<div class="highlight"><pre><span class="k">let</span> <span class="ss">x =</span> <span class="s2">&quot;value&quot;</span><span class="p">;</span> <span class="k">in</span> <span class="p">{</span><span class="ss">key =</span> x<span class="p">;}</span>
<span class="c1">#-&gt; { key = &quot;value&quot;; }</span>
</pre></div>

<p>Note that these are constant bindings to immutable values. You can reuse a bound name in an inner scope (&quot;shadowing&quot; it), but you can’t reassign it or otherwise change a value once it’s assigned. These aren’t what most languages call &quot;variables&quot;.</p>
<p>You can bind multiple names in a single <code>let</code> expression.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">x =</span> <span class="mi">1</span><span class="p">;</span>
  <span class="ss">y =</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">in</span>
  x <span class="o">+</span> y
<span class="c1">#-&gt; 3</span>
</pre></div>

<p><code>let</code> bindings are recursive, so names on the same level can refer to each other just like names in recursive sets.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">name =</span> <span class="s2">&quot;hello-</span><span class="si">${</span>version<span class="si">}</span><span class="s2">&quot;</span><span class="p">;</span>
  <span class="ss">version =</span> <span class="s2">&quot;1.0&quot;</span><span class="p">;</span>
<span class="k">in</span>
  name
<span class="c1">#-&gt; &quot;hello-1.0&quot;</span>
</pre></div>

<p>You should also know that a <code>let</code> binding is just another type of expression, so you can nest them.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">first =</span> <span class="p">(</span>
    <span class="k">let</span>
      <span class="ss">second =</span> <span class="s2">&quot;Hello&quot;</span><span class="p">;</span>
    <span class="k">in</span>
      second <span class="o">+</span> <span class="s2">&quot; &quot;</span>
  <span class="p">);</span>
<span class="k">in</span>
  <span class="k">let</span>
    <span class="ss">third =</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span>
  <span class="k">in</span>
    first <span class="o">+</span> third
<span class="c1">#-&gt; &quot;Hello world&quot;</span>
</pre></div>

<h3 id="_literal_with_literal_expression"><code>with</code> expression</h3>
<p>A <code>with</code> expression brings all the attributes in a set into scope. It exists purely for convenience, as it’s often much more pleasant than using fully qualified names or lots of <code>let</code> bindings instead.</p>
<table>
<colgroup>
<col width="33%" />
<col width="66%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>qualified names</p></td>
<td><div class="highlight"><pre><span class="k">let</span>
  <span class="ss">pkgs =</span> <span class="nb">import</span> <span class="l">&lt;nixpkgs&gt;</span> <span class="p">{};</span>
<span class="k">in</span>
  <span class="p">[</span>pkgs<span class="o">.</span>foo pkgs<span class="o">.</span>bar pkgs<span class="o">.</span>baz<span class="p">]</span>
</pre></div>
</td>
</tr>
<tr class="even">
<td><p>local bindings</p></td>
<td><div class="highlight"><pre><span class="k">let</span>
  <span class="ss">pkgs =</span> <span class="nb">import</span> <span class="l">&lt;nixpkgs&gt;</span> <span class="p">{};</span>
  <span class="ss">foo =</span> pkgs<span class="o">.</span>foo<span class="p">;</span>
  <span class="ss">bar =</span> pkgs<span class="o">.</span>bar<span class="p">;</span>
  <span class="ss">baz =</span> pkgs<span class="o">.</span>baz<span class="p">;</span>
<span class="k">in</span>
  <span class="p">[</span>foo bar baz<span class="p">]</span>
</pre></div>
</td>
</tr>
<tr class="odd">
<td><p><code>with</code> expression</p></td>
<td><div class="highlight"><pre><span class="k">let</span>
  <span class="ss">pkgs =</span> <span class="nb">import</span> <span class="l">&lt;nixpkgs&gt;</span> <span class="p">{};</span>
<span class="k">in</span>
  <span class="k">with</span> pkgs<span class="p">;</span>
  <span class="p">[</span>foo bar baz<span class="p">]</span>
</pre></div>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p>All 3 above examples evaluate to the same thing.</p>
</div>
<p>The one big caveat with <code>with</code> expressions is that a name bound by <code>with</code> <em>cannot shadow</em> a name that was already bound. Another way to think about this is that <em>explicit</em> <code>let</code> bindings take precedence over <em>implicit</em> <code>with</code> bindings, <em>even if</em> the <code>with</code> comes after.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">item =</span> <span class="s2">&quot;we want this&quot;</span><span class="p">;</span>
  <span class="ss">suspiciousSet =</span> <span class="p">{</span><span class="ss">item =</span> <span class="s2">&quot;we don't want this&quot;</span><span class="p">;};</span>
<span class="k">in</span>
  <span class="k">with</span> suspiciousSet<span class="p">;</span> item
<span class="c1">#-&gt; &quot;we want this&quot;</span>
</pre></div>

<p>This lets you use <code>with</code> on a set for convenience without fear that it might clobber your local bindings and break your code.</p>
<h2 id="_functions">Functions</h2>
<p>Basic function syntax is quite terse: you have an argument on the left and a function body on the right separated only by a <code>:</code>. It’s sometimes easy to miss if you’re not looking for it.</p>
<p>Here is a function which simply adds <code>1</code> to its argument.</p>
<div class="highlight"><pre>x<span class="p">:</span> x <span class="o">+</span> <span class="mi">1</span>
<span class="c1">#-&gt; &lt;LAMBDA&gt;</span>
</pre></div>

<p>Nix calls functions &quot;lambdas&quot;. There’s no distinction, and I only use &quot;function&quot; to avoid negative connotations from some languages where lambdas are second class. More importantly, aren’t strings in disguise like in <em>some</em> silly languages, so if you try to print one, Nix just says <code>«lambda»</code>.</p>
<p>To apply a function to an argument, simply place the argument after the function.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">add1 =</span> <span class="p">(</span>x<span class="p">:</span> x <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">in</span>
  add1 <span class="mi">2</span>
<span class="c1">#-&gt; 3</span>
</pre></div>

<div class="admonition note">
<p>The <code>add1 2</code> here could be called a &quot;function call&quot; or, equivalently, a &quot;function application&quot;. Nix favors &quot;application&quot;, so I will too, but just know that there’s no difference.</p>
</div>
<p>Just be careful to to use parentheses with function applications inside list literals, or else the function and arguments will become individual elements instead.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">add1 =</span> <span class="p">(</span>x<span class="p">:</span> x <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="k">in</span>
  <span class="p">[</span>
    <span class="mi">1</span>
    add1 <span class="mi">2</span>
    <span class="p">(</span>add1 <span class="mi">2</span><span class="p">)</span>
  <span class="p">]</span>
<span class="c1">#-&gt; [ 1 &lt;LAMBDA&gt; 2 3 ]</span>
</pre></div>

<h3 id="_currying">Currying</h3>
<p>All functions in Nix take exactly 1 argument (they’re &quot;unary&quot;). Technically speaking, you can’t define a function which takes more than 1 argument.</p>
<p>But this isn’t a limitation! We can get something that looks and behaves like a multi-argument function by writing it in a curried style: you write a function which takes the first argument, and it returns <em>another</em> function which takes the next argument, and when you have all your arguments in scope you can return the real result of the function.</p>
<div class="highlight"><pre><span class="p">(</span>x<span class="p">:</span> <span class="p">(</span>y<span class="p">:</span> x <span class="o">+</span> y<span class="p">))</span>
</pre></div>

<p>You can drop those parentheses without changing how the expression is grouped, which makes curried functions easier to read and write.</p>
<div class="highlight"><pre>x<span class="p">:</span> y<span class="p">:</span> x <span class="o">+</span> y
</pre></div>

<p>The <code>:</code> in a function definition is &quot;right associative&quot;, so <code>x: y: x + y</code> means the same thing as <code>(x: (y: (x + y)))</code>.</p>
<p>To use a curried function, simply supply all the arguments.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">add =</span> <span class="p">(</span>x<span class="p">:</span> y<span class="p">:</span> x <span class="o">+</span> y<span class="p">);</span>
<span class="k">in</span>
  add <span class="mi">1</span> <span class="mi">2</span>
<span class="c1">#-&gt; 3</span>
</pre></div>

<p>Function application is &quot;left associative&quot;, so <code>add 1 2</code> means the same thing as <code>(((add) 1) 2)</code>.</p>
<div class="admonition note">
<p>See <a href="#_appendix_a_currying">Appendix A: Currying</a> for more.</p>
</div>
<h3 id="_named_arguments">Named arguments</h3>
<p>Functions can also destructure attribute set arguments.</p>
<div class="highlight"><pre><span class="p">{</span>x<span class="p">,</span> y<span class="p">}:</span> x <span class="o">+</span> y
</pre></div>

<p>The above function expects a single set argument which has two elements: <code>x</code> and <code>y</code>. This is often used to pass named arguments to a function.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">add =</span> <span class="p">({</span>x<span class="p">,</span> y<span class="p">}:</span>
    x <span class="o">+</span> y
  <span class="p">);</span>
<span class="k">in</span>
  add <span class="p">{</span><span class="ss">x =</span> <span class="mi">1</span><span class="p">;</span> <span class="ss">y =</span> <span class="mi">2</span><span class="p">;}</span>
<span class="c1">#-&gt; 3</span>
</pre></div>

<p>Note that such a function requires an attribute set which has <em>exactly</em> the keys used in the pattern. Missing or unexpected keys will cause an error.</p>
<p>To allow extra keys to be ignored, you can mention <code>...</code>.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">hello =</span> <span class="p">({</span>name<span class="p">,</span> <span class="o">...</span><span class="p">}:</span>
    <span class="s2">&quot;Hello </span><span class="si">${</span>name<span class="si">}</span><span class="s2">&quot;</span>
  <span class="p">);</span>
<span class="k">in</span>
  hello <span class="p">{</span><span class="ss">name =</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span> <span class="ss">x =</span> <span class="no">false</span><span class="p">;}</span>
<span class="c1">#-&gt; &quot;Hello world&quot;</span>
</pre></div>

<p>To allow missing keys, you can give them default values with <code>?</code>.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">hello =</span> <span class="p">({</span>name <span class="o">?</span> <span class="s2">&quot;world&quot;</span><span class="p">}:</span>
    <span class="s2">&quot;Hello </span><span class="si">${</span>name<span class="si">}</span><span class="s2">&quot;</span>
  <span class="p">);</span>
<span class="k">in</span>
  hello <span class="p">{}</span>
<span class="c1">#-&gt; &quot;Hello world&quot;</span>
</pre></div>

<h2 id="_paths">Paths</h2>
<p>Where most languages treat file paths as simple strings, Nix has a special value type for paths. Roughly speaking, any word with <code>/</code> characters in it is parsed as a path literal.</p>
<div class="highlight"><pre><span class="nb">builtins</span><span class="o">.</span>typeOf <span class="l">/etc/nixos/configuration.nix</span>
<span class="c1">#-&gt; &quot;path&quot;</span>
</pre></div>

<p>If you write a relative path, it will automatically be resolved to an absolute path relative to the Nix file it’s written in (or relative to the current directory in <code>nix-repl</code> or <code>nix-instantiate</code>). Be sure to write it beginning with a <code>./</code> so it gets properly parsed as a path.</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<thead>
<tr class="header">
<th>~/blog/file.nix</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="highlight"><pre><span class="o">.</span><span class="l">/.gitignore</span>
<span class="c1">#-&gt; /Users/ryanartecona/blog/.gitignore</span>
</pre></div>
</td>
</tr>
</tbody>
</table>
<p>You can just as well use a path literal for directories, too. If referring to the directory of the current Nix file, be sure to spell it <code>./.</code> so it contains a slash.</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<thead>
<tr class="header">
<th>~/blog/file.nix</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="highlight"><pre><span class="o">.</span><span class="l">/.</span>
<span class="c1">#-&gt; /Users/ryanartecona/blog</span>
</pre></div>
</td>
</tr>
</tbody>
</table>
<p>You can append a path to a base path with <code>+</code>.</p>
<div class="highlight"><pre><span class="l">/path/to/project</span> <span class="o">+</span> <span class="l">/path/to/file.txt</span>
<span class="c1">#-&gt; /path/to/project/path/to/file.txt</span>
</pre></div>

<p>Just be sure the right-hand path is absolute, because if it’s relative, it almost certainly won’t be what you expect!</p>
<div class="highlight"><pre><span class="l">/path/to/project</span> <span class="o">+</span> <span class="l">path/to/file.txt</span>
<span class="c1">#-&gt; /path/to/project/Users/ryanartecona/blog/path/to/file.txt</span>
</pre></div>

<p>So paths totally aren’t strings. But if you ever need to, you can freely cast them back and forth.</p>
<div class="highlight"><pre><span class="nb">toString</span> <span class="l">/path/to/file.txt</span>
<span class="c1">#-&gt; &quot;/path/to/file.txt&quot;</span>
</pre></div>

<div class="highlight"><pre><span class="l">/.</span> <span class="o">+</span> <span class="s2">&quot;/path/to/file.txt&quot;</span>
<span class="c1">#-&gt; /path/to/file.txt</span>
</pre></div>

<div class="admonition note">
<p>There is also a <code>builtins.toPath</code> function to cast a string to a path, but it’s <a href=":https://github.com/NixOS/nix/issues/1074">currently broken</a>. In the meantime, this is a workaround.</p>
</div>
<p>Paths are useful for relative imports, which you will see next. Later on, you’ll also see that they have special semantics — different than strings! — when used in derivations.</p>
<h3 id="_todo_antiquoted_paths_in_derivations">TODO: antiquoted paths in derivations (?)</h3>
<h3 id="_todo_literal_nix_path_literal_amp_literal_lt_path_gt_literal">TODO: <code>NIX_PATH</code> &amp; <code>&lt;path&gt;</code></h3>
<div class="highlight"><pre>nix-instantiate -I <span class="nv">mypath</span><span class="o">=</span>./ --eval <span class="s2">&quot;&lt;mypath&gt;&quot;</span>
</pre></div>

<h2 id="_imports">Imports</h2>
<h3 id="_todo_imports">TODO: Imports</h3>
<p>At any point in a Nix expression, you may import some other Nix expression from a different file.</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<thead>
<tr class="header">
<th>file.nix</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="highlight"><pre><span class="p">{</span> <span class="ss">hello =</span> <span class="s2">&quot;world&quot;</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span class="nb">import</span> <span class="o">.</span><span class="l">/file.nix</span>
<span class="c1">#-&gt; { hello = &quot;world&quot;; }</span>
</pre></div>

<p>Because Nix is expressions all the way down, importing is quite simple to explain: a Nix file (e.g. <code>file.nix</code>) contains a single well-formed Nix expression, and when you import that file with <code>import ./file.nix</code>, it’s as if the <code>import ./file.nix</code> expression just gets replaced with the contents of <code>file.nix</code>.</p>
<p>For example, it’s common to extract common library functions into their own file, and <code>import</code> them where needed. Your library, call it <code>lib.nix</code>, will just be a big attribute set of functions or whatever other values, and the importing files can use <code>.</code> access syntax to use what they need.</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<thead>
<tr class="header">
<th>lib.nix</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="highlight"><pre><span class="p">{</span>
  <span class="ss">hello =</span> <span class="p">(</span>name<span class="p">:</span>
    <span class="s2">&quot;Hello, </span><span class="si">${</span>name<span class="si">}</span><span class="s2">!&quot;</span>
  <span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">lib =</span> <span class="nb">import</span> <span class="o">.</span><span class="l">/lib.nix</span><span class="p">;</span>
<span class="k">in</span>
  lib<span class="o">.</span>hello <span class="s2">&quot;world&quot;</span>
<span class="c1">#-&gt; &quot;Hello, world!&quot;</span>
</pre></div>

<p>Since <code>let</code> expressions are already available to create local bindings, you can use them to create private helpers that don’t get exposed publicly.</p>
<table>
<colgroup>
<col width="100%" />
</colgroup>
<thead>
<tr class="header">
<th>lib.nix</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><div class="highlight"><pre><span class="k">let</span>
  <span class="ss">greet =</span> <span class="p">({</span> pre<span class="p">,</span> post<span class="p">}:</span> name<span class="p">:</span>
    pre <span class="o">+</span> <span class="p">(</span><span class="nb">toString</span> name<span class="p">)</span> <span class="o">+</span> post
  <span class="p">);</span>
  <span class="ss">hello =</span> greet <span class="p">{</span> <span class="ss">pre =</span> <span class="s2">&quot;Hello, &quot;</span><span class="p">;</span> <span class="ss">post =</span> <span class="s2">&quot;!&quot;</span><span class="p">;</span> <span class="p">};</span>
  <span class="ss">goodbye =</span> greet <span class="p">{</span> <span class="ss">pre =</span> <span class="s2">&quot;Goodbye, &quot;</span><span class="p">;</span> <span class="ss">post =</span> <span class="s2">&quot;.&quot;</span><span class="p">;</span> <span class="p">};</span>
<span class="k">in</span>
  <span class="p">{</span> <span class="k">inherit</span> hello goodbye<span class="p">;</span> <span class="p">}</span>
</pre></div>
</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">lib =</span> <span class="nb">import</span> <span class="o">.</span><span class="l">/lib.nix</span><span class="p">;</span>
<span class="k">in</span>
  <span class="p">[</span> <span class="p">(</span>lib <span class="o">?</span> hello<span class="p">)</span> <span class="p">(</span>lib <span class="o">?</span> greet<span class="p">)</span> <span class="p">]</span>
<span class="c1">#-&gt; [ true false ]</span>
</pre></div>

<p>For Nix files which are libraries (attribute sets) of functions, it’s a common pattern to import the file and immediately bring all its elements into scope using <code>with</code>.</p>
<div class="highlight"><pre><span class="k">with</span> <span class="nb">import</span> <span class="o">.</span><span class="l">/lib.nix</span><span class="p">;</span>
hello <span class="s2">&quot;Nix&quot;</span>
<span class="c1">#-&gt; &quot;Hello, Nix!&quot;</span>
</pre></div>

<h1 id="_evaluation">Evaluation</h1>
<p>Evaluation in Nix is <em>lazy</em>. This is important to understand, but if you’re not already comfortable with a lazy language (e.g. Haskell), it may sound foreign and daunting. But don’t worry! Though it’s true that most languages aren’t pervasively lazy, it’s also true that lots of programming languages have <em>some</em> lazy elements, so laziness is likely just a familiar concept by an unfamiliar name.</p>
<p>Take the following Javascript snippet.</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">getTrue</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">throwError</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'derp'</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">getTrue</span><span class="p">()</span> <span class="o">||</span> <span class="nx">throwError</span><span class="p">()</span>
</pre></div>

<p>Does the above snippet throw an error? No it doesn’t! But why?</p>
<p>If you understand why, you know it’s because <code>||</code> only evaluates its right-hand side if its left-hand side evaluates to <code>false</code> (or something falsy). If the left-hand side is <code>true</code> (or truthy), then the whole compound expression can evaluate to whatever was on the left-hand side <em>without</em> evaluating the right-hand side at all. In the above example, the left-hand side is indeed <code>true</code>, so the right-hand side never gets evaluated, so we never see a thrown error.</p>
<p>This behavior is usually called &quot;short-circuiting&quot;, especially in the context of boolean operators. Turns out, this is also lazy evaluation! You could just as accurately say <code>||</code> and <code>&amp;&amp;</code> are lazy operators.</p>
<p>So, of course, Nix’s <code>||</code> and <code>&amp;&amp;</code> and other boolean operators are lazy, too.</p>
<div class="highlight"><pre><span class="no">true</span> <span class="o">||</span> <span class="p">(</span><span class="no">null</span> <span class="o">+</span> <span class="no">null</span><span class="p">)</span>
<span class="c1">#-&gt; true</span>
</pre></div>

<p>We know this didn’t evaluate the right-hand side, because if it did, we would’ve gotten an error.</p>
<div class="highlight"><pre><span class="no">null</span> <span class="o">+</span> <span class="no">null</span>
<span class="c1">#-&gt; error: cannot coerce null to a string, at (string):1:1</span>
</pre></div>

<p>So what does it mean for the <em>whole language</em> to be lazy? Well, in general, all expressions will avoid evaluating any of their subexpressions unless and until absolutely necessary.</p>
<p>A <code>let ... in ...</code> expression won’t evaluate one of its bound values until that value’s name is evaluated in the <code>in ...</code> body. We can prove this to ourselves by putting an <em>intentional bug</em> in our program, and if we never see an error, that will mean the buggy expression never got evaluated.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">bug =</span> <span class="p">(</span><span class="no">null</span> <span class="o">+</span> <span class="no">null</span><span class="p">);</span>
  <span class="ss">foo =</span> <span class="s2">&quot;bar&quot;</span><span class="p">;</span>
<span class="k">in</span>
  foo
<span class="c1">#-&gt; &quot;bar&quot;</span>
</pre></div>

<p>An attribute set won’t evaluate one of its values unless and until its corresponding key is accessed.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">bug =</span> <span class="p">(</span><span class="no">null</span> <span class="o">+</span> <span class="no">null</span><span class="p">);</span>
  <span class="ss">set =</span> <span class="p">{</span> <span class="ss">foo =</span> <span class="s2">&quot;bar&quot;</span><span class="p">;</span> <span class="ss">ohnoes =</span> bug<span class="p">;</span> <span class="p">};</span>
<span class="k">in</span>
  set<span class="o">.</span>foo
<span class="c1">#-&gt; &quot;bar&quot;</span>
</pre></div>

<p>A list also won’t evaluate its elements unless and until they are accessed.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">bug =</span> <span class="p">(</span><span class="no">null</span> <span class="o">+</span> <span class="no">null</span><span class="p">);</span>
  <span class="ss">list =</span> <span class="p">[</span> <span class="no">true</span> bug <span class="p">];</span>
<span class="k">in</span>
  <span class="nb">builtins</span><span class="o">.</span>elemAt list <span class="mi">0</span>
<span class="c1">#-&gt; true</span>
</pre></div>

<p>An import of another Nix file won’t actually go open the file unless and until it’s evaluated.</p>
<div class="highlight"><pre><span class="k">with</span> <span class="nb">import</span> <span class="l">/a/path/to/some/file/that/does/not/exist.nix</span><span class="p">;</span>
<span class="s2">&quot;coolio&quot;</span>
<span class="c1">#-&gt; &quot;coolio&quot;</span>
</pre></div>

<p>Now, here’s the extra weird one. Most programming languages will evaluate a functions' arguments <em>before</em> calling a function with the supplied arguments. Nix doesn’t. When you apply a function to an argument (or arguments, in curried style), that argument <em>may not</em> have already been evaluated when the application evaluates. Moreover, if the function body avoids evaluating that argument, it may <em>remain</em> unevaluated even after the function &quot;returns&quot; (or more precisely, after the application fully evaluates)!</p>
<p>Here’s an example. If I write a function <code>const</code> which takes 2 curried arguments, and just gives back the first argument without evaluating the second argument, then I can give <code>const</code> a buggy expression as its second argument and <em>still</em> never see a resulting error.</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">bug =</span> <span class="p">(</span><span class="no">null</span> <span class="o">+</span> <span class="no">null</span><span class="p">);</span>
  <span class="ss">const =</span> <span class="p">(</span>x<span class="p">:</span> y<span class="p">:</span>
    x
  <span class="p">);</span>
<span class="k">in</span>
  const <span class="no">true</span> bug
<span class="c1">#-&gt; true</span>
</pre></div>

<p>In contrast, here’s an example of a function <code>ifThenElse</code> that I’ve often wished I could write in Javascript.</p>
<div class="highlight"><pre><span class="kd">function</span> <span class="nx">ifThenElse</span><span class="p">(</span><span class="nx">condition</span><span class="p">,</span> <span class="nx">thenBranch</span><span class="p">,</span> <span class="nx">elseBranch</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">condition</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">thenBranch</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">elseBranch</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">throwError</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s1">'derp'</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">ifThenElse</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="s2">&quot;coolio&quot;</span><span class="p">,</span> <span class="nx">throwError</span><span class="p">());</span>
<span class="err">#</span><span class="o">-&gt;</span> <span class="nx">Uncaught</span> <span class="nb">Error</span><span class="o">:</span> <span class="nx">derp</span>
</pre></div>

<p>Do you see why this doesn’t work? The <code>throwError()</code> argument is evaluated before <code>ifThenElse</code> is even called, so our program derps out instead of just returning <code>&quot;coolio&quot;</code>. This is why you can’t write a function that short-circuits quite the same as an <code>if</code> statement or a <code>&amp;&amp;</code> operator, because function arguments get evaluated before the function gets called. (You can work around this limitation in Javascript with anonymous functions and the like, but it’s not quite the same.)</p>
<p>But in Nix, this would work!</p>
<div class="highlight"><pre><span class="k">let</span>
  <span class="ss">ifThenElse =</span> <span class="p">(</span>condition<span class="p">:</span> thenBranch<span class="p">:</span> elseBranch<span class="p">:</span>
    <span class="k">if</span> condition <span class="k">then</span>
      thenBranch
    <span class="k">else</span>
      elseBranch
  <span class="p">);</span>
  <span class="ss">throwError =</span> <span class="p">({}:</span>
    <span class="no">null</span> <span class="o">+</span> <span class="no">null</span>
  <span class="p">);</span>
<span class="k">in</span>
  ifThenElse <span class="no">true</span> <span class="s2">&quot;coolio&quot;</span> <span class="p">(</span>throwError <span class="p">{})</span>
<span class="c1">#-&gt; &quot;coolio&quot;</span>
</pre></div>

<p>Coolio indeed. This works without throwing an error because Nix is a pervasively lazy language. <em>That’s</em> what it means for a language to be lazy.</p>
<h2 id="_todo_traces">TODO: Traces</h2>
<h2 id="_todo_errors_exceptions_assertions_aborts">TODO: Errors (exceptions, assertions, aborts)</h2>
<h1 id="_standard_library">Standard library</h1>
<h2 id="_builtins">builtins</h2>
<h3 id="_todo_builtins">TODO: builtins</h3>
<h2 id="_literal_nixpkgs_lib_literal"><code>nixpkgs/lib</code></h2>
<h3 id="_todo_nixpkgs_lib">TODO: nixpkgs/lib</h3>
<h1 id="_appendix">Appendix</h1>
<h2 id="_appendix_a_currying">Appendix A: Currying</h2>
<p>If you’re unfamiliar with currying, here’s how a curried <code>add</code> function could be written and used in Javascript.</p>
<div class="highlight"><pre><span class="kr">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="k">return</span> <span class="p">((</span><span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">})};</span>
<span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="c1">//-&gt; (y) =&gt; {return x + y}</span>
<span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)(</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">//-&gt; 3</span>
<span class="kr">const</span> <span class="nx">add1</span> <span class="o">=</span> <span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="nx">add1</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="c1">//-&gt; 3</span>
</pre></div>

<p>If you’d like to read up more on currying, introductory blog posts abound. You can google for one in your language of choice. If you understand what’s going on above, though, that’s really all there is to it.</p>
  </div>
</div>

        </div>
      </div>

    </div>

  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-28816340-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
  </body>
</html>
